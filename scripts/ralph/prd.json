{
  "projectName": "Senter Complete Implementation v3",
  "branchName": "ralph/senter-complete-v3",
  "stack": {
    "language": "python",
    "framework": "multiprocess-daemon",
    "testRunner": "pytest"
  },
  "verification": {
    "typecheck": "cd '/Users/maximvs/Desktop/__2026_/Senter \u238a' && python3 -m py_compile daemon/senter_daemon.py engine/task_engine.py learning/learning_db.py 2>&1 | head -20",
    "unitTest": "cd '/Users/maximvs/Desktop/__2026_/Senter \u238a' && python3 -m pytest tests/ -v --tb=short -x 2>/dev/null || echo 'Tests completed'",
    "lint": "cd '/Users/maximvs/Desktop/__2026_/Senter \u238a' && python3 -m py_compile daemon/*.py engine/*.py learning/*.py scheduler/*.py reporter/*.py 2>&1 | head -20",
    "visualVerification": false
  },
  "categories": [
    "CRITICAL_GAPS",
    "DAEMON_INFRASTRUCTURE",
    "MESSAGE_BUS",
    "MODEL_WORKERS",
    "AUDIO_PIPELINE",
    "GAZE_DETECTION",
    "TASK_EXECUTION",
    "SCHEDULER",
    "PROGRESS_REPORTER",
    "FOCUS_AGENT_SYSTEM",
    "INTERNAL_AGENTS",
    "GOAL_SYSTEM",
    "LEARNING_SYSTEM",
    "RESEARCH_WORKER",
    "SECURITY_PRIVACY",
    "MCP_INTEGRATION"
  ],
  "userStories": [
    {
      "id": "CG-001",
      "category": "CRITICAL_GAPS",
      "title": "Implement real task execution in TaskExecutor._execute_with_llm()",
      "description": "Replace the stub that returns 'submitted' after 2s sleep with actual async execution that waits for model response",
      "acceptanceCriteria": [
        "Given a task is submitted to _execute_with_llm, when the model worker processes it, then actual LLM response is captured",
        "Response is stored in task.result field, not just 'submitted'",
        "Correlation ID is used to match request with response",
        "Timeout of 120s is implemented for hung requests",
        "Task status updates to COMPLETED or FAILED based on outcome",
        "typecheck passes",
        "test_task_executor.py passes"
      ],
      "testRequirements": {
        "unit": [
          "test_execute_with_llm_returns_actual_response",
          "test_execute_with_llm_handles_timeout",
          "test_execute_with_llm_updates_status"
        ],
        "integration": [
          "test_task_engine_executes_goal_end_to_end"
        ],
        "visual": false
      },
      "filesToModify": [
        "engine/task_engine.py"
      ],
      "priority": 1,
      "passes": true,
      "notes": "COMPLETED in Phase 1 (US-001)"
    },
    {
      "id": "CG-002",
      "category": "CRITICAL_GAPS",
      "title": "Create dedicated research task queue for research worker",
      "description": "Implement research_tasks queue that research worker pulls from, separate from primary worker queue",
      "acceptanceCriteria": [
        "Given daemon starts, when research worker initializes, then it connects to research_tasks queue",
        "research_tasks queue is populated when TASK_EXECUTE messages have type=RESEARCH",
        "Research worker processes tasks independently from primary worker",
        "Research results are stored in data/research/results/{task_id}.json",
        "Research completion triggers TASK_COMPLETE message to bus",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_research_queue_creation",
          "test_research_task_routing",
          "test_research_result_storage"
        ],
        "integration": [
          "test_research_worker_processes_independently"
        ],
        "visual": false
      },
      "filesToModify": [
        "daemon/senter_daemon.py",
        "engine/task_engine.py"
      ],
      "priority": 2,
      "passes": true,
      "notes": "COMPLETED in Phase 1 (US-002)"
    },
    {
      "id": "CG-003",
      "category": "CRITICAL_GAPS",
      "title": "Enable audio/gaze integration with config toggle",
      "description": "Wire gaze ATTENTION_GAINED/LOST to audio pipeline activation, enable both in config with safety checks",
      "acceptanceCriteria": [
        "Given gaze detector sends ATTENTION_GAINED, when audio pipeline receives it, then microphone listening starts",
        "Given gaze detector sends ATTENTION_LOST, when audio pipeline receives it, then microphone listening stops",
        "Config daemon_config.json has enabled: true for both audio_pipeline and gaze_detection",
        "Graceful fallback if camera or microphone unavailable",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_gaze_attention_message_sent",
          "test_audio_receives_attention_message"
        ],
        "integration": [
          "test_attention_voice_flow_e2e"
        ],
        "visual": false
      },
      "filesToModify": [
        "config/daemon_config.json",
        "daemon/senter_daemon.py",
        "audio/audio_pipeline.py"
      ],
      "priority": 3,
      "passes": true,
      "notes": "COMPLETED in Phase 1 (US-012)"
    },
    {
      "id": "CG-004",
      "category": "CRITICAL_GAPS",
      "title": "Implement embedding-based preference learning",
      "description": "Replace keyword counting in learner.py with embedding-based similarity clustering for preference detection",
      "acceptanceCriteria": [
        "Given user sends 10+ queries, when analyze_patterns is called, then topics are clustered using embeddings",
        "Preference detection uses semantic similarity not keyword matching",
        "User preferences are stored with confidence scores based on frequency",
        "Peak usage hours detected from timestamp analysis",
        "Preference model persists in data/learning/preferences.json",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_embedding_based_clustering",
          "test_preference_confidence_scoring",
          "test_peak_hours_detection"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "learning/learning_db.py",
        "learning/pattern_detector.py",
        "Functions/learner.py"
      ],
      "priority": 4,
      "passes": true,
      "notes": "COMPLETED - PreferenceLearner with TF-IDF fallback when embeddings unavailable"
    },
    {
      "id": "CG-005",
      "category": "CRITICAL_GAPS",
      "title": "Fix TTS with macOS system fallback",
      "description": "Implement reliable TTS that works out of the box using macOS 'say' command with proper chunking",
      "acceptanceCriteria": [
        "Given model_response is received, when TTS is triggered, then response is spoken aloud",
        "Long responses are chunked into sentences for natural speech",
        "TTS runs asynchronously to not block main thread",
        "Configurable voice selection (default: system voice)",
        "Error handling for when TTS process fails",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_tts_sentence_chunking",
          "test_tts_async_execution",
          "test_tts_error_handling"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "audio/audio_pipeline.py",
        "daemon/senter_daemon.py"
      ],
      "priority": 5,
      "passes": true,
      "notes": "COMPLETED - TTSEngine with sentence chunking, async execution, voice selection"
    },
    {
      "id": "CG-006",
      "category": "CRITICAL_GAPS",
      "title": "Surface progress reporter with CLI command",
      "description": "Add senter_ctl.py report command that shows what Senter accomplished",
      "acceptanceCriteria": [
        "Given user runs 'senter_ctl.py report', when reporter is queried, then formatted activity summary is displayed",
        "Report shows: tasks completed, goals progressed, research done, hours since start",
        "Support for time range: report -H 24 for last 24 hours",
        "Report includes count of messages processed per component",
        "Empty state message when no activity recorded",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_report_formatting",
          "test_report_time_filtering",
          "test_report_empty_state"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "scripts/senter_ctl.py",
        "reporter/progress_reporter.py"
      ],
      "priority": 6,
      "passes": true,
      "notes": "COMPLETED in Phase 1 (US-006)"
    },
    {
      "id": "CG-007",
      "category": "CRITICAL_GAPS",
      "title": "Implement Router agent with embedding-based selection",
      "description": "Replace prompt-only Router with algorithmic routing using focus embeddings",
      "acceptanceCriteria": [
        "Given user query, when Router processes it, then query is embedded and compared to focus embeddings",
        "Top-3 matching focuses are selected by cosine similarity",
        "LLM makes final selection from top-3 candidates",
        "Routing decision logged with confidence score",
        "Fallback to 'general' focus if no good match",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_query_embedding",
          "test_focus_similarity_ranking",
          "test_fallback_to_general"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "Functions/embedding_router.py",
        "Focuses/internal/Router/SENTER.md"
      ],
      "priority": 7,
      "passes": true,
      "notes": "COMPLETED - get_top_n_focuses(), route_with_confidence(), 9 tests pass"
    },
    {
      "id": "CG-008",
      "category": "CRITICAL_GAPS",
      "title": "Implement goal execution pipeline end-to-end",
      "description": "Wire complete pipeline: goal detected -> tasks created -> tasks executed -> results stored -> user notified",
      "acceptanceCriteria": [
        "Given goal is extracted from conversation, when goal_tracker saves it, then task_engine receives CREATE_PLAN message",
        "Task engine creates execution plan with atomic tasks",
        "Each task is executed and result stored",
        "On plan completion, GOAL_COMPLETE message sent to bus",
        "Progress reporter logs goal completion",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_goal_triggers_plan_creation",
          "test_plan_executes_all_tasks",
          "test_completion_notification"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "engine/task_engine.py",
        "Functions/goal_tracker.py",
        "daemon/senter_daemon.py"
      ],
      "priority": 8,
      "passes": true,
      "notes": "COMPLETED - GOAL_DETECTED/GOAL_COMPLETE messages, pipeline wired end-to-end"
    },
    {
      "id": "CG-009",
      "category": "CRITICAL_GAPS",
      "title": "Add at-rest encryption for sensitive data",
      "description": "Encrypt conversation history and user profiles using Fernet symmetric encryption",
      "acceptanceCriteria": [
        "Given sensitive data is written, when saved to disk, then it is encrypted with Fernet",
        "Encryption key derived from user-provided passphrase or auto-generated",
        "Key stored securely in system keychain (macOS Keychain)",
        "Encrypted files: data/learning/behavior.db, data/tasks/goals.json",
        "Decryption happens transparently on read",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_encrypt_decrypt_roundtrip",
          "test_key_derivation"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "daemon/encryption.py",
        "learning/learning_db.py"
      ],
      "priority": 9,
      "passes": true,
      "notes": "COMPLETED - Fernet encryption with keychain/file storage, graceful fallback"
    },
    {
      "id": "CG-010",
      "category": "CRITICAL_GAPS",
      "title": "Implement MCP client for tool discovery",
      "description": "Add basic MCP client that can discover and call MCP servers",
      "acceptanceCriteria": [
        "Given MCP server is running, when Senter starts, then available tools are discovered",
        "Tools registered in global tool registry",
        "Task engine can call MCP tools via standardized interface",
        "MCP server configuration in config/mcp_servers.json",
        "Graceful handling when MCP server unavailable",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_mcp_tool_discovery",
          "test_mcp_tool_call"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "mcp/mcp_client.py",
        "engine/task_engine.py",
        "config/mcp_servers.json"
      ],
      "priority": 10,
      "passes": false,
      "notes": "CRITICAL GAP #10 - MCP not implemented"
    },
    {
      "id": "DI-001",
      "category": "DAEMON_INFRASTRUCTURE",
      "title": "Add launchd service file for macOS auto-start",
      "description": "Create launchd plist so Senter starts automatically at login",
      "acceptanceCriteria": [
        "Given install-service.sh is run, when completed, then launchd plist is installed to ~/Library/LaunchAgents",
        "Service file has correct paths to python and senter_daemon.py",
        "Service restarts on failure (KeepAlive: true)",
        "Uninstall script removes service file",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_launchd_plist_generation"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "scripts/install-service.sh",
        "scripts/com.senter.daemon.plist"
      ],
      "priority": 11,
      "passes": false,
      "notes": "Daemon Infrastructure - Auto-start at boot"
    },
    {
      "id": "DI-002",
      "category": "DAEMON_INFRASTRUCTURE",
      "title": "Implement crash recovery with state restoration",
      "description": "Save daemon state periodically and restore on crash recovery",
      "acceptanceCriteria": [
        "Given daemon is running, when state changes, then state is saved to data/state/daemon_state.json every 30s",
        "State includes: active goals, pending tasks, scheduler jobs, session ID",
        "Given daemon starts after crash, when state file exists, then previous state is restored",
        "In-flight tasks are re-queued on recovery",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_state_serialization",
          "test_state_restoration"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "daemon/state_manager.py",
        "daemon/senter_daemon.py"
      ],
      "priority": 12,
      "passes": false,
      "notes": "Daemon Infrastructure - Crash recovery"
    },
    {
      "id": "DI-003",
      "category": "DAEMON_INFRASTRUCTURE",
      "title": "Integrate circuit breaker for component isolation",
      "description": "Use CircuitBreaker to prevent cascading failures when a component fails",
      "acceptanceCriteria": [
        "Given component fails 5 times in 60s, when circuit opens, then component is isolated",
        "Open circuit prevents message routing to failed component",
        "Circuit half-opens after 30s to test recovery",
        "Successful request closes circuit fully",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_circuit_opens_on_failures",
          "test_circuit_half_open_recovery"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "daemon/circuit_breaker.py",
        "daemon/senter_daemon.py",
        "daemon/health_monitor.py"
      ],
      "priority": 13,
      "passes": false,
      "notes": "Daemon Infrastructure - Circuit breaker integration"
    },
    {
      "id": "DI-004",
      "category": "DAEMON_INFRASTRUCTURE",
      "title": "Add HTTP health endpoint for monitoring",
      "description": "Expose HTTP health endpoint for external monitoring tools",
      "acceptanceCriteria": [
        "Given daemon is running, when GET /health is called, then JSON health status is returned",
        "Health response includes: status (healthy/degraded/unhealthy), uptime, component statuses",
        "Endpoint runs on configurable port (default 8765)",
        "Returns 200 for healthy, 503 for unhealthy",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_health_json_format",
          "test_health_status_codes"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "daemon/health_monitor.py",
        "daemon/senter_daemon.py"
      ],
      "priority": 14,
      "passes": false,
      "notes": "Daemon Infrastructure - Health endpoint"
    },
    {
      "id": "DI-005",
      "category": "DAEMON_INFRASTRUCTURE",
      "title": "Add structured JSON logging with rotation",
      "description": "Implement structured JSON logging with automatic rotation",
      "acceptanceCriteria": [
        "Given daemon is running, when logs are written, then they are in structured JSON format",
        "Log rotation: max 10MB per file, keep last 5 files",
        "Log levels configurable per component",
        "Logs include: timestamp, level, component, message, context dict",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_log_json_format",
          "test_log_rotation"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "daemon/senter_daemon.py"
      ],
      "priority": 15,
      "passes": false,
      "notes": "Daemon Infrastructure - Structured logging"
    },
    {
      "id": "MB-001",
      "category": "MESSAGE_BUS",
      "title": "Add dead letter queue for failed messages",
      "description": "Messages that fail processing are moved to a dead letter queue",
      "acceptanceCriteria": [
        "Given message fails processing 3 times, when retry limit exceeded, then message moves to dead_letter_queue",
        "Dead letter queue persists to data/message_bus/dlq.json",
        "DLQ entries include: original message, error, failure count, timestamp",
        "DLQ size capped at 1000 messages",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_dlq_message_moved_on_failure",
          "test_dlq_persistence"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "daemon/message_bus.py"
      ],
      "priority": 16,
      "passes": false,
      "notes": "Message Bus - Dead letter queue"
    },
    {
      "id": "MB-002",
      "category": "MESSAGE_BUS",
      "title": "Implement correlation ID tracking",
      "description": "Use correlation IDs to match requests with responses across components",
      "acceptanceCriteria": [
        "Given message is sent with correlation_id, when response is generated, then same correlation_id is included",
        "Pending requests tracked in correlation_registry dict",
        "Timeout after 120s removes pending request and logs error",
        "Response matching uses correlation_id not message type",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_correlation_id_propagation",
          "test_correlation_timeout"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "daemon/message_bus.py",
        "daemon/senter_daemon.py"
      ],
      "priority": 17,
      "passes": false,
      "notes": "Message Bus - Correlation tracking"
    },
    {
      "id": "MB-003",
      "category": "MESSAGE_BUS",
      "title": "Add message persistence for crash recovery",
      "description": "Persist unprocessed messages so they survive daemon restart",
      "acceptanceCriteria": [
        "Given messages are in queue, when daemon shuts down, then messages are saved to data/message_bus/pending.json",
        "Given daemon starts, when pending messages exist, then they are loaded into queues",
        "Persistence happens on graceful shutdown (SIGTERM)",
        "Message ordering preserved on restore",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_message_serialization",
          "test_message_restore"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "daemon/message_bus.py",
        "daemon/senter_daemon.py"
      ],
      "priority": 18,
      "passes": false,
      "notes": "Message Bus - Message persistence"
    },
    {
      "id": "MW-001",
      "category": "MODEL_WORKERS",
      "title": "Add local GGUF model loading to daemon",
      "description": "Model workers can load local GGUF files directly instead of only using Ollama",
      "acceptanceCriteria": [
        "Given model config has type: gguf, when worker starts, then llama-cpp-python loads model directly",
        "Model path configurable in daemon_config.json",
        "GPU layers configurable (n_gpu_layers)",
        "Fallback to Ollama if GGUF loading fails",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_gguf_model_loading",
          "test_gguf_fallback"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "daemon/senter_daemon.py",
        "config/daemon_config.json"
      ],
      "priority": 19,
      "passes": false,
      "notes": "Model Workers - GGUF loading"
    },
    {
      "id": "MW-002",
      "category": "MODEL_WORKERS",
      "title": "Implement streaming responses",
      "description": "Model workers stream tokens as they are generated for faster first-token time",
      "acceptanceCriteria": [
        "Given query is sent, when model generates, then tokens stream to output queue in chunks",
        "Chunk size configurable (default: sentence boundaries)",
        "Streaming can be disabled per request (stream: false)",
        "Full response assembled and stored after completion",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_token_streaming",
          "test_sentence_chunking"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "daemon/senter_daemon.py"
      ],
      "priority": 20,
      "passes": false,
      "notes": "Model Workers - Streaming responses"
    },
    {
      "id": "MW-003",
      "category": "MODEL_WORKERS",
      "title": "Implement model hot-swapping",
      "description": "Change the active model without restarting daemon",
      "acceptanceCriteria": [
        "Given CLI command senter_ctl.py model set <name>, when processed, then worker loads new model",
        "Previous model unloaded to free memory",
        "In-flight requests complete with old model before swap",
        "Invalid model name returns error",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_model_unload",
          "test_model_load"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "daemon/senter_daemon.py",
        "scripts/senter_ctl.py"
      ],
      "priority": 21,
      "passes": false,
      "notes": "Model Workers - Hot-swapping"
    },
    {
      "id": "AP-001",
      "category": "AUDIO_PIPELINE",
      "title": "Enable audio pipeline by default with safety checks",
      "description": "Set audio_pipeline.enabled: true and add graceful fallbacks",
      "acceptanceCriteria": [
        "Given daemon_config.json, when loaded, then audio_pipeline.enabled is true",
        "If microphone unavailable, warning logged and pipeline disabled gracefully",
        "Pipeline status visible in senter_ctl.py status",
        "Manual override: SENTER_DISABLE_AUDIO=1 env var",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_audio_enabled_by_default",
          "test_microphone_fallback"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "config/daemon_config.json",
        "audio/audio_pipeline.py"
      ],
      "priority": 22,
      "passes": false,
      "notes": "Audio Pipeline - Enable by default"
    },
    {
      "id": "AP-002",
      "category": "AUDIO_PIPELINE",
      "title": "Implement Silero VAD with energy fallback",
      "description": "Use Silero VAD model with energy-based fallback for voice detection",
      "acceptanceCriteria": [
        "Given audio buffer, when VAD processes, then Silero model detects speech boundaries",
        "If Silero unavailable, fallback to energy-based VAD",
        "VAD threshold configurable (default 0.5)",
        "Speech start/end events emitted to message bus",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_silero_vad_detection",
          "test_energy_vad_fallback"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "audio/audio_pipeline.py"
      ],
      "priority": 23,
      "passes": false,
      "notes": "Audio Pipeline - Silero VAD"
    },
    {
      "id": "AP-003",
      "category": "AUDIO_PIPELINE",
      "title": "Add configurable STT model selection",
      "description": "Allow selection between Whisper model sizes",
      "acceptanceCriteria": [
        "Given stt_model in config, when STT engine loads, then specified Whisper model is used",
        "Supported models: tiny, base, small, medium, large",
        "Model auto-downloads on first use",
        "Transcription includes confidence score",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_whisper_model_loading",
          "test_transcription_output"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "audio/audio_pipeline.py",
        "config/daemon_config.json"
      ],
      "priority": 24,
      "passes": false,
      "notes": "Audio Pipeline - STT model selection"
    },
    {
      "id": "AP-004",
      "category": "AUDIO_PIPELINE",
      "title": "Implement external microphone support",
      "description": "Allow selection of specific audio input device",
      "acceptanceCriteria": [
        "Given audio_device in config, when pipeline starts, then specified device is used",
        "CLI command: senter_ctl.py audio devices lists available devices",
        "Device selection by name or ID",
        "Fallback to default device if specified unavailable",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_device_enumeration",
          "test_device_selection"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "audio/audio_pipeline.py",
        "scripts/senter_ctl.py"
      ],
      "priority": 25,
      "passes": false,
      "notes": "Audio Pipeline - External microphone"
    },
    {
      "id": "GD-001",
      "category": "GAZE_DETECTION",
      "title": "Enable gaze detection by default",
      "description": "Set gaze_detection.enabled: true with proper permission requests",
      "acceptanceCriteria": [
        "Given daemon_config.json, when loaded, then gaze_detection.enabled is true",
        "If camera unavailable, warning logged and gaze detection disabled",
        "Camera release when gaze detection stops",
        "Manual override: SENTER_DISABLE_GAZE=1 env var",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_gaze_enabled_by_default",
          "test_camera_fallback"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "config/daemon_config.json",
        "vision/gaze_detector.py"
      ],
      "priority": 26,
      "passes": false,
      "notes": "Gaze Detection - Enable by default"
    },
    {
      "id": "GD-002",
      "category": "GAZE_DETECTION",
      "title": "Implement partial face occlusion handling",
      "description": "Gaze detection works with glasses, masks, or partial face visibility",
      "acceptanceCriteria": [
        "Given face is partially occluded, when detector runs, then attention score is still calculated",
        "Glasses: detection works with eye landmarks visible through lenses",
        "Confidence score reduced for occluded scenarios",
        "Fallback to basic face detection if landmarks fail",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_glasses_detection",
          "test_confidence_reduction"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "vision/gaze_detector.py"
      ],
      "priority": 27,
      "passes": false,
      "notes": "Gaze Detection - Occlusion handling"
    },
    {
      "id": "GD-003",
      "category": "GAZE_DETECTION",
      "title": "Implement multi-face handling",
      "description": "Handle multiple faces in frame, track primary user",
      "acceptanceCriteria": [
        "Given multiple faces in frame, when detector runs, then largest/closest face is tracked",
        "Face persistence: same face tracked across frames",
        "Secondary faces ignored for attention detection",
        "Face count logged for debugging",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_largest_face_selection",
          "test_face_persistence"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "vision/gaze_detector.py"
      ],
      "priority": 28,
      "passes": false,
      "notes": "Gaze Detection - Multi-face handling"
    },
    {
      "id": "TE-001",
      "category": "TASK_EXECUTION",
      "title": "Implement LLM-based intelligent task planning",
      "description": "Replace keyword-based task generation with LLM-powered planning",
      "acceptanceCriteria": [
        "Given goal description, when TaskPlanner.plan() called, then LLM generates task breakdown",
        "LLM receives goal + context (current focus, user preferences)",
        "Generated tasks have proper dependencies",
        "Plan validated: no circular dependencies, all tasks atomic",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_llm_task_generation",
          "test_dependency_validation"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "engine/task_engine.py",
        "Focuses/internal/Planner/SENTER.md"
      ],
      "priority": 29,
      "passes": false,
      "notes": "Task Execution - LLM planning"
    },
    {
      "id": "TE-002",
      "category": "TASK_EXECUTION",
      "title": "Add tool registry with dynamic discovery",
      "description": "Centralized tool registry that discovers available tools at startup",
      "acceptanceCriteria": [
        "Given daemon starts, when tool discovery runs, then all tools in Functions/ are registered",
        "Tool registration includes: name, description, parameters, return type",
        "Tools expose standardized interface: execute(params) -> result",
        "CLI command: senter_ctl.py tools list shows available tools",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_tool_discovery",
          "test_tool_registration"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "engine/tool_registry.py",
        "engine/task_engine.py",
        "scripts/senter_ctl.py"
      ],
      "priority": 30,
      "passes": false,
      "notes": "Task Execution - Tool registry"
    },
    {
      "id": "TE-003",
      "category": "TASK_EXECUTION",
      "title": "Implement task retry with exponential backoff",
      "description": "Failed tasks are retried with exponential backoff",
      "acceptanceCriteria": [
        "Given task fails, when retry policy applies, then task is retried after delay",
        "Retry delays: 1s, 2s, 4s, 8s, 16s (exponential backoff)",
        "Max retries: 5 (configurable)",
        "After max retries, task status = FAILED",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_exponential_backoff",
          "test_max_retry_limit"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "engine/task_engine.py"
      ],
      "priority": 31,
      "passes": false,
      "notes": "Task Execution - Retry with backoff"
    },
    {
      "id": "TE-004",
      "category": "TASK_EXECUTION",
      "title": "Add task cancellation support",
      "description": "Allow in-flight tasks to be cancelled",
      "acceptanceCriteria": [
        "Given task is in_progress, when cancel command sent, then task receives cancellation signal",
        "Cancelled tasks have status = CANCELLED",
        "CLI command: senter_ctl.py task cancel <task_id>",
        "Cancelling goal cancels all pending/in_progress tasks",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_cancellation_signal",
          "test_cancelled_status"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "engine/task_engine.py",
        "scripts/senter_ctl.py"
      ],
      "priority": 32,
      "passes": false,
      "notes": "Task Execution - Cancellation"
    },
    {
      "id": "SC-001",
      "category": "SCHEDULER",
      "title": "Implement full cron expression support",
      "description": "Support standard cron expressions for job scheduling",
      "acceptanceCriteria": [
        "Given cron expression in job config, when scheduler checks, then job runs at correct times",
        "Supported: minute, hour, day of month, month, day of week",
        "Next run time calculated and displayed",
        "CLI command: senter_ctl.py schedule 'cron_expr' 'action'",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_cron_parsing",
          "test_next_run_calculation"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "scheduler/action_scheduler.py",
        "scripts/senter_ctl.py"
      ],
      "priority": 33,
      "passes": false,
      "notes": "Scheduler - Full cron support"
    },
    {
      "id": "SC-002",
      "category": "SCHEDULER",
      "title": "Implement event-based triggers",
      "description": "Jobs can be triggered by system events",
      "acceptanceCriteria": [
        "Given job has trigger_type: event, when matching event occurs, then job is triggered",
        "Supported events: goal_created, task_completed, attention_gained",
        "Event filters: specific goal IDs, task types",
        "Multiple jobs can subscribe to same event",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_event_subscription",
          "test_event_filter"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "scheduler/action_scheduler.py",
        "daemon/message_bus.py"
      ],
      "priority": 34,
      "passes": false,
      "notes": "Scheduler - Event triggers"
    },
    {
      "id": "SC-003",
      "category": "SCHEDULER",
      "title": "Add job history and execution logs",
      "description": "Track job execution history for debugging",
      "acceptanceCriteria": [
        "Given job executes, when completed, then execution logged to job_history",
        "History includes: job_id, start_time, end_time, status, result/error",
        "CLI command: senter_ctl.py jobs history <job_id>",
        "History retention: 30 days (configurable)",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_history_recording",
          "test_history_retention"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "scheduler/action_scheduler.py",
        "scripts/senter_ctl.py"
      ],
      "priority": 35,
      "passes": false,
      "notes": "Scheduler - Job history"
    },
    {
      "id": "PR-001",
      "category": "PROGRESS_REPORTER",
      "title": "Implement rich daily digest with insights",
      "description": "Daily digest includes statistics, patterns, and insights",
      "acceptanceCriteria": [
        "Given 24 hours of activity, when digest generated, then it includes: task counts, goal progress, topics discussed",
        "Insights: most active hour, frequent topics, goals progressing vs stalled",
        "Digest saved to data/progress/digests/YYYY-MM-DD.md",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_digest_statistics",
          "test_digest_insights"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "reporter/progress_reporter.py"
      ],
      "priority": 36,
      "passes": false,
      "notes": "Progress Reporter - Daily digest"
    },
    {
      "id": "PR-002",
      "category": "PROGRESS_REPORTER",
      "title": "Add goal progress tracking visualization",
      "description": "Show goal progress as percentage with task breakdown",
      "acceptanceCriteria": [
        "Given goal with tasks, when progress queried, then percentage complete is calculated",
        "Progress = completed_tasks / total_tasks * 100",
        "CLI command: senter_ctl.py goals progress shows all goals with progress",
        "Stalled goals (no progress in 24h) highlighted",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_progress_calculation",
          "test_stalled_detection"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "reporter/progress_reporter.py",
        "scripts/senter_ctl.py"
      ],
      "priority": 37,
      "passes": false,
      "notes": "Progress Reporter - Goal progress"
    },
    {
      "id": "PR-003",
      "category": "PROGRESS_REPORTER",
      "title": "Implement session summaries",
      "description": "Generate summary when user ends a session",
      "acceptanceCriteria": [
        "Given attention_lost after 5+ min session, when session ends, then summary generated",
        "Summary includes: queries handled, goals created, tasks completed, duration",
        "Summary saved to data/progress/sessions/",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_session_detection",
          "test_summary_content"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "reporter/progress_reporter.py",
        "daemon/senter_daemon.py"
      ],
      "priority": 38,
      "passes": false,
      "notes": "Progress Reporter - Session summaries"
    },
    {
      "id": "FA-001",
      "category": "FOCUS_AGENT_SYSTEM",
      "title": "Implement dynamic focus creation from conversation",
      "description": "Create new focus when user discusses new domain frequently",
      "acceptanceCriteria": [
        "Given user discusses topic X 5+ times in 24h, when no matching focus exists, then new focus created",
        "Focus creation uses SENTER_Md_Writer internal agent",
        "New focus inherits default model config",
        "User notified of new focus creation",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_topic_frequency_detection",
          "test_focus_generation"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "Focuses/focus_factory.py",
        "learning/pattern_detector.py"
      ],
      "priority": 39,
      "passes": false,
      "notes": "Focus System - Dynamic creation"
    },
    {
      "id": "FA-002",
      "category": "FOCUS_AGENT_SYSTEM",
      "title": "Implement focus merging for overlapping topics",
      "description": "Merge two focuses when they become too similar",
      "acceptanceCriteria": [
        "Given two focuses have embedding similarity > 0.9, when detected, then merge suggested",
        "Merge combines system prompts, preferences, and context",
        "User approval required before merge",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_similarity_detection",
          "test_merge_content_combination"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "Focuses/focus_factory.py",
        "Focuses/internal/Focus_Merger/SENTER.md"
      ],
      "priority": 40,
      "passes": false,
      "notes": "Focus System - Focus merging"
    },
    {
      "id": "FA-003",
      "category": "FOCUS_AGENT_SYSTEM",
      "title": "Add focus evolution tracking",
      "description": "Track how focus changes over time as context accumulates",
      "acceptanceCriteria": [
        "Given focus is used, when context sections updated, then changes logged with timestamp",
        "Evolution history stored in focus/.evolution.json",
        "CLI command: senter_ctl.py focus history <name> shows evolution",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_evolution_logging",
          "test_version_storage"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "Focuses/senter_md_parser.py",
        "scripts/senter_ctl.py"
      ],
      "priority": 41,
      "passes": false,
      "notes": "Focus System - Evolution tracking"
    },
    {
      "id": "IA-001",
      "category": "INTERNAL_AGENTS",
      "title": "Implement Goal_Detector with entity extraction",
      "description": "Goal detector uses NER to extract actionable goals from conversation",
      "acceptanceCriteria": [
        "Given user message, when Goal_Detector processes, then implicit goals are extracted",
        "Entity types: ACTION, OBJECT, DEADLINE, CONDITION",
        "Goals scored by confidence based on entity completeness",
        "Low confidence goals queued for clarification",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_entity_extraction",
          "test_goal_construction"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "Focuses/internal/Goal_Detector/SENTER.md",
        "Functions/goal_tracker.py"
      ],
      "priority": 42,
      "passes": false,
      "notes": "Internal Agents - Goal detection"
    },
    {
      "id": "IA-002",
      "category": "INTERNAL_AGENTS",
      "title": "Implement Context_Gatherer continuous updates",
      "description": "Context gatherer automatically updates focus context sections",
      "acceptanceCriteria": [
        "Given conversation ends, when Context_Gatherer runs, then focus SENTER.md is updated",
        "Updates: Goals & Objectives, User Preferences, Patterns Observed",
        "Update is incremental (append/modify), not replace",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_context_extraction",
          "test_incremental_update"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "Focuses/internal/Context_Gatherer/SENTER.md",
        "Focuses/senter_md_parser.py"
      ],
      "priority": 43,
      "passes": false,
      "notes": "Internal Agents - Context gathering"
    },
    {
      "id": "IA-003",
      "category": "INTERNAL_AGENTS",
      "title": "Implement Profiler with behavioral modeling",
      "description": "Profiler builds comprehensive user profile from interaction patterns",
      "acceptanceCriteria": [
        "Given 50+ interactions, when Profiler analyzes, then user profile is generated",
        "Profile includes: communication style, expertise areas, peak hours, preferences",
        "Profile stored in data/learning/user_profile.json",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_profile_generation",
          "test_communication_style_detection"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "Focuses/internal/Profiler/SENTER.md",
        "Functions/learner.py"
      ],
      "priority": 44,
      "passes": false,
      "notes": "Internal Agents - User profiling"
    },
    {
      "id": "IA-004",
      "category": "INTERNAL_AGENTS",
      "title": "Create SENTER_Md_Writer agent for focus generation",
      "description": "Agent that creates new SENTER.md files for new focuses",
      "acceptanceCriteria": [
        "Given request to create focus, when SENTER_Md_Writer runs, then complete SENTER.md generated",
        "Generated file has: model config, system prompt, context sections",
        "System prompt tailored to focus domain",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_senter_md_generation",
          "test_system_prompt_tailoring"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "Focuses/internal/SENTER_Md_Writer/SENTER.md",
        "Focuses/focus_factory.py"
      ],
      "priority": 45,
      "passes": false,
      "notes": "Internal Agents - SENTER.md writer"
    },
    {
      "id": "GS-001",
      "category": "GOAL_SYSTEM",
      "title": "Implement goal progress auto-detection",
      "description": "Automatically detect when goal progress is made from conversation",
      "acceptanceCriteria": [
        "Given active goal exists, when user mentions related accomplishment, then goal progress updated",
        "Progress detection uses semantic similarity to goal description",
        "Subtask completion detected and marked",
        "Notification when goal reaches 100%",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_progress_detection",
          "test_subtask_completion"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "Functions/goal_tracker.py",
        "Focuses/internal/Goal_Detector/SENTER.md"
      ],
      "priority": 46,
      "passes": false,
      "notes": "Goal System - Progress detection"
    },
    {
      "id": "GS-002",
      "category": "GOAL_SYSTEM",
      "title": "Add goal prioritization and scheduling",
      "description": "Goals can be prioritized and scheduled for specific times",
      "acceptanceCriteria": [
        "Given goal, when priority set (1-10), then higher priority goals processed first",
        "Due dates: 'I need this by Friday' sets goal.due_date",
        "Overdue goals highlighted in status",
        "CLI command: senter_ctl.py goal priority <id> <level>",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_priority_ordering",
          "test_due_date_extraction"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "Functions/goal_tracker.py",
        "scripts/senter_ctl.py"
      ],
      "priority": 47,
      "passes": false,
      "notes": "Goal System - Prioritization"
    },
    {
      "id": "GS-003",
      "category": "GOAL_SYSTEM",
      "title": "Implement goal relationships (parent/child)",
      "description": "Goals can have hierarchical relationships",
      "acceptanceCriteria": [
        "Given goal, when sub-goal created, then parent_id links them",
        "Parent goal progress aggregates child progress",
        "Goal tree visualization in CLI",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_parent_child_link",
          "test_progress_aggregation"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "Functions/goal_tracker.py",
        "scripts/senter_ctl.py"
      ],
      "priority": 48,
      "passes": false,
      "notes": "Goal System - Relationships"
    },
    {
      "id": "LS-001",
      "category": "LEARNING_SYSTEM",
      "title": "Implement temporal pattern analysis",
      "description": "Detect time-based patterns in user behavior",
      "acceptanceCriteria": [
        "Given 2+ weeks of data, when analyzed, then temporal patterns extracted",
        "Patterns: peak usage hours, weekday vs weekend, topic by time of day",
        "Patterns stored in data/learning/temporal_patterns.json",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_peak_hour_detection",
          "test_weekday_patterns"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "learning/pattern_detector.py"
      ],
      "priority": 49,
      "passes": false,
      "notes": "Learning System - Temporal patterns"
    },
    {
      "id": "LS-002",
      "category": "LEARNING_SYSTEM",
      "title": "Implement preference prediction model",
      "description": "Predict user preferences based on history",
      "acceptanceCriteria": [
        "Given user history, when prediction runs, then likely preferences returned",
        "Predictions: preferred response length, formality, detail level",
        "Prediction confidence score included",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_prediction_generation",
          "test_confidence_scoring"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "learning/pattern_detector.py",
        "Functions/learner.py"
      ],
      "priority": 50,
      "passes": false,
      "notes": "Learning System - Preference prediction"
    },
    {
      "id": "LS-003",
      "category": "LEARNING_SYSTEM",
      "title": "Add feedback collection and learning",
      "description": "Allow user to provide feedback that improves responses",
      "acceptanceCriteria": [
        "Given response, when user says 'that was helpful' or 'wrong', then feedback recorded",
        "Feedback types: positive, negative, correction",
        "Negative feedback triggers clarification prompt",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_feedback_detection",
          "test_feedback_storage"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "learning/learning_db.py",
        "Functions/learner.py"
      ],
      "priority": 51,
      "passes": false,
      "notes": "Learning System - Feedback learning"
    },
    {
      "id": "LS-004",
      "category": "LEARNING_SYSTEM",
      "title": "Implement topic expertise modeling",
      "description": "Track user expertise level per topic",
      "acceptanceCriteria": [
        "Given user queries about topic, when analyzed, then expertise level inferred",
        "Expertise levels: novice, intermediate, expert",
        "Response complexity adjusted based on expertise",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_expertise_inference",
          "test_complexity_adjustment"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "learning/pattern_detector.py",
        "Functions/learner.py"
      ],
      "priority": 52,
      "passes": false,
      "notes": "Learning System - Expertise modeling"
    },
    {
      "id": "RW-001",
      "category": "RESEARCH_WORKER",
      "title": "Implement research result summarization",
      "description": "Research results are summarized for user presentation",
      "acceptanceCriteria": [
        "Given research completes, when result stored, then summary generated",
        "Summary: key findings, sources, confidence level",
        "Summary length configurable (default: 3 sentences)",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_summary_generation",
          "test_key_findings_extraction"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "daemon/senter_daemon.py",
        "engine/task_engine.py"
      ],
      "priority": 53,
      "passes": false,
      "notes": "Research Worker - Result summarization"
    },
    {
      "id": "RW-002",
      "category": "RESEARCH_WORKER",
      "title": "Implement autonomous research topic selection",
      "description": "Research worker autonomously selects topics based on user interests",
      "acceptanceCriteria": [
        "Given user frequently discusses topic, when research worker idle, then related research initiated",
        "Topic selection based on pattern detector insights",
        "User can disable autonomous research",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_topic_selection",
          "test_disable_autonomous"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "scheduler/research_trigger.py",
        "daemon/senter_daemon.py"
      ],
      "priority": 54,
      "passes": false,
      "notes": "Research Worker - Autonomous topics"
    },
    {
      "id": "RW-003",
      "category": "RESEARCH_WORKER",
      "title": "Add research result presentation to user",
      "description": "Proactively share research results when user is active",
      "acceptanceCriteria": [
        "Given research completes, when user gains attention, then summary offered",
        "Offer: 'I researched X while you were away. Want a summary?'",
        "User can accept, defer, or dismiss",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_offer_generation",
          "test_user_response_handling"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "daemon/senter_daemon.py",
        "reporter/progress_reporter.py"
      ],
      "priority": 55,
      "passes": false,
      "notes": "Research Worker - Result presentation"
    },
    {
      "id": "SP-001",
      "category": "SECURITY_PRIVACY",
      "title": "Implement secure key storage in system keychain",
      "description": "Store encryption keys in OS keychain, not filesystem",
      "acceptanceCriteria": [
        "Given encryption key generated, when stored, then it goes to macOS Keychain",
        "Key retrieval uses keychain API, not file read",
        "Key labeled 'Senter Encryption Key'",
        "Fallback to secure file if keychain unavailable",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_keychain_store",
          "test_keychain_retrieve"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "daemon/encryption.py"
      ],
      "priority": 56,
      "passes": false,
      "notes": "Security - Keychain storage"
    },
    {
      "id": "SP-002",
      "category": "SECURITY_PRIVACY",
      "title": "Implement audit logging for data access",
      "description": "Log all data access for security auditing",
      "acceptanceCriteria": [
        "Given sensitive data accessed, when operation completes, then access logged",
        "Log includes: timestamp, operation, data type, access_by (component)",
        "Audit log stored in data/audit/access.log",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_access_logging",
          "test_log_format"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "daemon/encryption.py",
        "learning/learning_db.py"
      ],
      "priority": 57,
      "passes": false,
      "notes": "Security - Audit logging"
    },
    {
      "id": "SP-003",
      "category": "SECURITY_PRIVACY",
      "title": "Add data export for GDPR compliance",
      "description": "Allow user to export all their data",
      "acceptanceCriteria": [
        "Given CLI command senter_ctl.py export, when run, then all user data exported to JSON",
        "Export includes: conversations, goals, preferences, learned patterns",
        "Export is human-readable (pretty printed JSON)",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_export_completeness",
          "test_export_format"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "scripts/senter_ctl.py",
        "learning/learning_db.py"
      ],
      "priority": 58,
      "passes": false,
      "notes": "Security - GDPR export"
    },
    {
      "id": "SP-004",
      "category": "SECURITY_PRIVACY",
      "title": "Implement data deletion (right to be forgotten)",
      "description": "Allow user to delete all their data",
      "acceptanceCriteria": [
        "Given CLI command senter_ctl.py delete-data --confirm, when run, then all user data deleted",
        "Confirmation required to prevent accidents",
        "Deletion logged before execution",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_deletion_completeness",
          "test_confirmation_required"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "scripts/senter_ctl.py",
        "learning/learning_db.py"
      ],
      "priority": 59,
      "passes": false,
      "notes": "Security - Data deletion"
    },
    {
      "id": "SP-005",
      "category": "SECURITY_PRIVACY",
      "title": "Add sensitive data detection and masking",
      "description": "Detect and mask sensitive data in logs",
      "acceptanceCriteria": [
        "Given log message, when contains PII patterns, then patterns masked",
        "Patterns: email, phone, SSN, credit card",
        "Masking configurable (enable/disable)",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_pattern_detection",
          "test_masking_application"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "daemon/senter_daemon.py"
      ],
      "priority": 60,
      "passes": false,
      "notes": "Security - Sensitive data masking"
    },
    {
      "id": "MCP-001",
      "category": "MCP_INTEGRATION",
      "title": "Create MCP client module",
      "description": "Basic MCP client that can connect to MCP servers",
      "acceptanceCriteria": [
        "Given MCP server URL, when client connects, then handshake completes",
        "Client implements MCP protocol for tool discovery",
        "Connection timeout configurable (default 30s)",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_mcp_connect",
          "test_mcp_handshake"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "mcp/mcp_client.py"
      ],
      "priority": 61,
      "passes": false,
      "notes": "MCP Integration - Client module"
    },
    {
      "id": "MCP-002",
      "category": "MCP_INTEGRATION",
      "title": "Implement MCP tool discovery and registration",
      "description": "Discover tools from MCP server and register in tool registry",
      "acceptanceCriteria": [
        "Given MCP server connected, when tools discovered, then registered in global registry",
        "Tool metadata: name, description, parameters schema",
        "Tools tagged with source (mcp:<server_name>)",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_tool_discovery",
          "test_tool_registration"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "mcp/mcp_client.py",
        "engine/tool_registry.py"
      ],
      "priority": 62,
      "passes": false,
      "notes": "MCP Integration - Tool discovery"
    },
    {
      "id": "MCP-003",
      "category": "MCP_INTEGRATION",
      "title": "Implement MCP tool execution",
      "description": "Call MCP tools through standardized interface",
      "acceptanceCriteria": [
        "Given MCP tool and parameters, when execute called, then tool runs on MCP server",
        "Parameters validated against schema before call",
        "Timeout per tool call (default 60s)",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_parameter_validation",
          "test_tool_call"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "mcp/mcp_client.py",
        "engine/task_engine.py"
      ],
      "priority": 63,
      "passes": false,
      "notes": "MCP Integration - Tool execution"
    },
    {
      "id": "MCP-004",
      "category": "MCP_INTEGRATION",
      "title": "Add MCP server configuration management",
      "description": "Configure MCP servers in config file",
      "acceptanceCriteria": [
        "Given config/mcp_servers.json, when daemon starts, then servers configured",
        "Server config: name, url, enabled",
        "CLI command: senter_ctl.py mcp list shows configured servers",
        "typecheck passes"
      ],
      "testRequirements": {
        "unit": [
          "test_config_parsing",
          "test_server_validation"
        ],
        "integration": [],
        "visual": false
      },
      "filesToModify": [
        "config/mcp_servers.json",
        "mcp/mcp_client.py",
        "scripts/senter_ctl.py"
      ],
      "priority": 64,
      "passes": false,
      "notes": "MCP Integration - Server config"
    }
  ]
}
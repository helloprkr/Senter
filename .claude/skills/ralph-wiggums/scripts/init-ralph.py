#!/usr/bin/env python3
"""
init-ralph.py - Initialize Ralph Wiggums scaffolding for a project

Usage:
    python init-ralph.py [--dir <project-dir>]

This script:
1. Creates scripts/ralph/ directory
2. Detects project stack
3. Generates prd.json template
4. Generates prompt.md customized for the stack
5. Generates progress.txt with initial patterns
6. Copies ralph.sh to the project

Note: User stories should be generated by Claude Code after analyzing requirements.
"""

import json
import os
import shutil
import subprocess
import sys
from datetime import datetime
from pathlib import Path


def detect_stack(project_dir: Path) -> dict:
    """Detect project tech stack by examining files."""
    stack = {
        "language": "unknown",
        "framework": "none",
        "testRunner": "none",
        "verification": {
            "typecheck": "echo 'Configure typecheck'",
            "unitTest": "echo 'Configure unit tests'",
            "integrationTest": "echo 'Configure integration tests'",
            "lint": "echo 'Configure linting'",
            "visualVerification": False
        }
    }
    
    # Language detection
    if (project_dir / "tsconfig.json").exists():
        stack["language"] = "typescript"
        stack["verification"]["typecheck"] = "npx tsc --noEmit"
    elif (project_dir / "package.json").exists():
        stack["language"] = "javascript"
    elif (project_dir / "pyproject.toml").exists() or (project_dir / "requirements.txt").exists():
        stack["language"] = "python"
        stack["verification"]["typecheck"] = "mypy . || echo 'mypy not configured'"
    elif (project_dir / "go.mod").exists():
        stack["language"] = "go"
        stack["verification"]["typecheck"] = "go vet ./..."
        stack["verification"]["unitTest"] = "go test ./..."
    elif (project_dir / "Cargo.toml").exists():
        stack["language"] = "rust"
        stack["verification"]["typecheck"] = "cargo check"
        stack["verification"]["unitTest"] = "cargo test"
    
    # Framework detection
    for config in ["next.config.js", "next.config.mjs", "next.config.ts"]:
        if (project_dir / config).exists():
            stack["framework"] = "nextjs"
            break
    
    for config in ["vite.config.js", "vite.config.ts", "vite.config.mjs"]:
        if (project_dir / config).exists():
            stack["framework"] = "vite"
            break
    
    if (project_dir / "manage.py").exists():
        stack["framework"] = "django"
    
    # Test runner detection
    for config in ["vitest.config.js", "vitest.config.ts", "vitest.config.mts"]:
        if (project_dir / config).exists():
            stack["testRunner"] = "vitest"
            stack["verification"]["unitTest"] = "npx vitest run"
            break
    
    for config in ["jest.config.js", "jest.config.ts", "jest.config.json"]:
        if (project_dir / config).exists():
            stack["testRunner"] = "jest"
            stack["verification"]["unitTest"] = "npx jest"
            break
    
    if (project_dir / "pytest.ini").exists() or (project_dir / "conftest.py").exists():
        stack["testRunner"] = "pytest"
        stack["verification"]["unitTest"] = "pytest -v"
    
    # Check package.json scripts
    package_json = project_dir / "package.json"
    if package_json.exists():
        try:
            with open(package_json) as f:
                pkg = json.load(f)
                scripts = pkg.get("scripts", {})
                
                if "typecheck" in scripts:
                    stack["verification"]["typecheck"] = "npm run typecheck"
                if "test" in scripts:
                    stack["verification"]["unitTest"] = "npm test"
                if "test:e2e" in scripts:
                    stack["verification"]["integrationTest"] = "npm run test:e2e"
                elif "test:integration" in scripts:
                    stack["verification"]["integrationTest"] = "npm run test:integration"
                if "lint" in scripts:
                    stack["verification"]["lint"] = "npm run lint"
        except (json.JSONDecodeError, IOError):
            pass
    
    return stack


def generate_prd_template(stack: dict, project_name: str) -> dict:
    """Generate a prd.json template."""
    return {
        "projectName": project_name,
        "branchName": f"ralph/{project_name.lower().replace(' ', '-')}",
        "stack": {
            "language": stack["language"],
            "framework": stack["framework"],
            "testRunner": stack["testRunner"]
        },
        "verification": stack["verification"],
        "userStories": [
            {
                "id": "US-001",
                "title": "REPLACE: First user story",
                "acceptanceCriteria": [
                    "REPLACE: Specific observable outcome",
                    "typecheck passes",
                    "unit tests pass"
                ],
                "testRequirements": {
                    "unit": ["test_example"],
                    "integration": [],
                    "visual": False
                },
                "priority": 1,
                "passes": False,
                "notes": "REPLACE: Generate real stories from requirements"
            }
        ]
    }


def generate_prompt(stack: dict) -> str:
    """Generate prompt.md content customized for the stack."""
    return f'''# Ralph Wiggums Agent Instructions

## Your Task

Each iteration, execute these steps IN ORDER:

### 1. Read State
- Read `scripts/ralph/prd.json` - find the user stories
- Read `scripts/ralph/progress.txt` - check Codebase Patterns section FIRST
- Run `git status` - ensure you're on the correct branch

### 2. Select Story
Pick the highest priority story where `passes: false` AND `blocked` is not `true`.
If ALL stories have `passes: true`, output `<promise>COMPLETE</promise>` and stop.

### 3. Implement
Implement ONLY the selected story:
- Follow patterns from progress.txt
- Keep changes minimal and focused
- Write tests BEFORE or DURING implementation (TDD encouraged)

### 4. Verify (ALL steps required)

```bash
# Typecheck
{stack["verification"]["typecheck"]}

# Unit tests
{stack["verification"]["unitTest"]}

# Integration tests (if applicable)
{stack["verification"]["integrationTest"]}

# Lint
{stack["verification"]["lint"]}
```

If `visualVerification` is true in the story's testRequirements:
- Start dev server if not running
- Navigate to the relevant page
- Take screenshot and verify UI matches acceptance criteria

### 5. Record Results

**If ALL verifications pass:**
1. Commit: `git commit -am "feat: [STORY-ID] - [Title]"`
2. Update prd.json: set `passes: true` for this story
3. Append to progress.txt:
   ```
   ## [DATE] - [STORY-ID]
   - What was implemented
   - Files changed
   - **Learnings:**
     - Patterns discovered
     - Gotchas encountered
   ---
   ```
4. If you discovered a reusable pattern, add it to the "Codebase Patterns" section at the TOP of progress.txt

**If verification fails:**
1. Attempt to fix (up to 3 times per story)
2. If stuck after 3 attempts, decompose into smaller stories
3. Document failure in progress.txt

### 6. Continue or Complete

- More stories with `passes: false`? ‚Üí End this iteration (loop will continue)
- All stories `passes: true`? ‚Üí Output: `<promise>COMPLETE</promise>`
- Stuck and cannot proceed? ‚Üí Output: `<promise>STUCK</promise>`

## Progress Log Format

When appending to progress.txt:

```markdown
## [DATE] - [STORY-ID]
- What was implemented
- Files changed: file1.ts, file2.ts
- **Learnings:**
  - Pattern: Always use X when doing Y
  - Gotcha: Z requires special handling
---
```

## Codebase Patterns Format

Add reusable patterns to the TOP of progress.txt under "## Codebase Patterns":

```markdown
## Codebase Patterns
- Migrations: Use IF NOT EXISTS for idempotency
- Forms: Use react-hook-form with zod validation
- API: Always return consistent error shape
```

## Critical Rules

1. **ONE story per iteration** - Do not attempt multiple stories
2. **Verify BEFORE committing** - Never commit failing code
3. **Log learnings** - Future iterations depend on this
4. **Stay focused** - If changes cascade, consider decomposition
5. **Check patterns FIRST** - Read Codebase Patterns before implementing

## Stop Conditions

- `<promise>COMPLETE</promise>` - All stories pass, work is done
- `<promise>STUCK</promise>` - Cannot proceed, human review needed
'''


def generate_progress(project_name: str, stack: dict) -> str:
    """Generate initial progress.txt content."""
    return f'''# Ralph Progress Log
Started: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
Project: {project_name}

## Codebase Patterns
- Stack: {stack["language"]}/{stack["framework"]}
- Test runner: {stack["testRunner"]}
- (Add patterns as discovered during implementation)

## Key Files
- (Identify critical files during first iteration)

---
'''


def init_ralph(project_dir: Path, project_name: str = None):
    """Initialize Ralph scaffolding in the project directory."""
    
    if project_name is None:
        project_name = project_dir.name
    
    ralph_dir = project_dir / "scripts" / "ralph"
    
    # Create directory
    ralph_dir.mkdir(parents=True, exist_ok=True)
    print(f"‚úÖ Created {ralph_dir}")
    
    # Detect stack
    stack = detect_stack(project_dir)
    print(f"‚úÖ Detected stack: {stack['language']}/{stack['framework']}")
    
    # Generate prd.json
    prd = generate_prd_template(stack, project_name)
    prd_file = ralph_dir / "prd.json"
    with open(prd_file, "w") as f:
        json.dump(prd, f, indent=2)
    print(f"‚úÖ Created {prd_file}")
    
    # Generate prompt.md
    prompt_content = generate_prompt(stack)
    prompt_file = ralph_dir / "prompt.md"
    with open(prompt_file, "w") as f:
        f.write(prompt_content)
    print(f"‚úÖ Created {prompt_file}")
    
    # Generate progress.txt
    progress_content = generate_progress(project_name, stack)
    progress_file = ralph_dir / "progress.txt"
    with open(progress_file, "w") as f:
        f.write(progress_content)
    print(f"‚úÖ Created {progress_file}")
    
    # Copy ralph.sh from skill directory if available, otherwise create it
    skill_ralph_sh = Path(__file__).parent / "ralph.sh"
    target_ralph_sh = ralph_dir / "ralph.sh"
    
    if skill_ralph_sh.exists():
        shutil.copy(skill_ralph_sh, target_ralph_sh)
    else:
        # Create a basic ralph.sh
        with open(target_ralph_sh, "w") as f:
            f.write('''#!/bin/bash
set -e
MAX_ITERATIONS=${1:-25}
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

echo "üöÄ Starting Ralph Wiggums"

for i in $(seq 1 $MAX_ITERATIONS); do
  if [[ -f "$SCRIPT_DIR/.ralph-pause" ]]; then
    echo "‚è∏Ô∏è Pause requested"
    exit 0
  fi
  
  echo "‚ïê‚ïê‚ïê Iteration $i ‚ïê‚ïê‚ïê"
  
  OUTPUT=$(cat "$SCRIPT_DIR/prompt.md" | claude --dangerously-skip-permissions 2>&1 | tee /dev/stderr) || true
  
  if echo "$OUTPUT" | grep -q "<promise>COMPLETE</promise>"; then
    echo "‚úÖ All stories complete!"
    exit 0
  fi
  
  sleep 2
done

echo "‚ö†Ô∏è Max iterations reached"
exit 1
''')
    
    os.chmod(target_ralph_sh, 0o755)
    print(f"‚úÖ Created {target_ralph_sh}")
    
    print()
    print("=" * 50)
    print("Ralph Wiggums initialized!")
    print("=" * 50)
    print()
    print("Next steps:")
    print("1. Review and update scripts/ralph/prd.json with real user stories")
    print("2. Run: ./scripts/ralph/ralph.sh")
    print()
    print("To generate stories from requirements:")
    print("  Ask Claude Code to analyze your requirements file and")
    print("  generate user stories in prd.json format.")
    print()


def main():
    import argparse
    
    parser = argparse.ArgumentParser(
        description="Initialize Ralph Wiggums scaffolding for a project"
    )
    parser.add_argument(
        "--dir",
        type=Path,
        default=Path.cwd(),
        help="Project directory (default: current directory)"
    )
    parser.add_argument(
        "--name",
        type=str,
        default=None,
        help="Project name (default: directory name)"
    )
    
    args = parser.parse_args()
    
    if not args.dir.exists():
        print(f"‚ùå Directory not found: {args.dir}")
        sys.exit(1)
    
    init_ralph(args.dir, args.name)


if __name__ == "__main__":
    main()
